package graphicsproj3;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.image.BufferedImage;
import javax.swing.*;
import java.util.Random;

/**
 * Drawer.java.
 * This class handles drawing and displaying lines on a 
 * BufferedImage. The BufferedImage is then displayed on
 * a JFrame using Java's Swing library.
 * @author Lou Oriondo
 * @version v1.0
 * @since 9/26/2014
 */
public class Drawer {
   
    public static JFrame frame;
    public static JPanel graph;
    public static BufferedImage img;
    public static Color b;
    public static Color w;
    public static int black;
    public static Random random;
    public static final int shortMax = 200;
    public static final int longMax = 500;
    public static long endTime = 0;
    /**
     * Constructor.
     */
    public Drawer(){
        img = new BufferedImage(512, 512, BufferedImage.TYPE_INT_RGB);
        b = Color.black;
        w = Color.white;
        black = b.getRGB();
        random = new Random();
    }// Constructor
    
    /**
     * display().
     * Creates the top level container for the JPanel
     * and BufferedImage where lines are drawn and displayed.
     */
    public void display(){
        frame = new JFrame("Perspective Projection!");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
       
        graph = new JPanel();
        graph.setPreferredSize(new Dimension(512,512));
        //graph.setBorder(BorderFactory.createEtchedBorder());
        
        img.getGraphics().setColor(w);
        img.getGraphics().fillRect(0, 0, 512, 512);
        
        graph.add(new JLabel(new ImageIcon(img)));
        frame.add(graph);
        frame.pack();
        frame.setVisible(true);
    }// display()
    
    /**
     * close().
     * Disposes all resources used by the JFrame and closes the
     * window. Called in main.java
     */
    public static void close(){
        frame.dispose();
    }//close()

    /**
     * draw().
     * Function called to generate the coordinates for the lines 
     * being drawn. Coordinates are generated by a random number
     * generator, of which the exclusive upper bound of the randomly
     * generated numbers are decided by what line-length the user
     * requests. Once coordinates are generated, the chosen algorithm
     * is called.
     * 
     * @param alg Integer provided from input
     * @param numLines Integer provided from input, number of lines to draw
     * @param length String input, either 'short' or 'long' lines to be drawn
     * @param type Integer input from 0 - 2, decides line type (i.e. dotted)
     */
    public static void draw(int alg, int numLines, String length, int type){
        if(alg == 1){ //SimpleLineScan Algorithm
            int x0 = 0;
            int y0 = 0;
            int x1 = 0;
            int y1 = 0;
            for(int i = 0; i < numLines; i++){
                if(length.toLowerCase().equals("short")){
                    x0 = random.nextInt(shortMax);
                    y0 = random.nextInt(shortMax);
                    x1 = random.nextInt(shortMax);
                    y1 = random.nextInt(shortMax);

                    
                }else if(length.toLowerCase().equals("long")){
                    x0 = random.nextInt(longMax);
                    y0 = random.nextInt(longMax);
                    x1 = random.nextInt(longMax);
                    y1 = random.nextInt(longMax);
                }
                try{
                    simpleLineScan(x0, y0, x1, y1, type);
                }catch(ArrayIndexOutOfBoundsException e){
                    // Some coordinates naturally go out of bounds once drawn.
                    //System.out.println("Re-creating coordinate.");
                    i--;
                }
            }
        }else if(alg == 2){ //Bresenham's Line Algorithm
            int x0 = 0;
            int y0 = 0;
            int x1 = 0;
            int y1 = 0;
            for(int i = 0; i < numLines; i++){
                if(length.toLowerCase().equals("short")){
                    /*x0 = random.nextInt(shortMax);
                    y0 = random.nextInt(shortMax);
                    x1 = random.nextInt(shortMax);
                    y1 = random.nextInt(shortMax);*/
                    
                    x0 = 10;
                    y0 = 10;
                    x1 = 300;
                    y1 = 300;
                }else if(length.toLowerCase().equals("long")){
                    x0 = random.nextInt(longMax);
                    y0 = random.nextInt(longMax);
                    x1 = random.nextInt(longMax);
                    y1 = random.nextInt(longMax);
                }
                try{
                    bresenham(x0, y0, x1, y1, type);
                }catch(ArrayIndexOutOfBoundsException e){
                    // Some coordinates naturally go out of bounds once drawn.
                    //System.out.println("Re-creating coordinate");
                    i--;
                }
            }
        }
    }// draw
    
    /**
     * simpleLineScan().
     * Simple line scan conversion algorithm. Algorithm adapted
     * from notes taken in lecture in CSCI4800.
     * 
     * @param x0 Integer - lower bound x coordinate of the line
     * @param y0 Integer - lower bound y coordinate of the line
     * @param x1 Integer - upper bound x coordinate of the line
     * @param y1 Integer - upper bound y coordinate of the line
     * @param dLength - Integer line type, i.e. 0 creates a solid line
     */
    public static void simpleLineScan(int x0, int y0, int x1, int y1, int dLength){
        long startTime = System.nanoTime();
        
        if(x0 > x1){
            int temp = x0;
            x0 = x1;
            x1 = temp;
        }
        int dx = x1 - x0;
        int dy = y1 - y0;

        if(x0 == x1){
            //System.out.println("Case 1");
            for(int i = 0; i < dy; i++){
                int x = x0;
                y0 = y0 + 1;

                if(dLength == 1){
                    if(i % 2 == 0){
                        img.setRGB(x, y0, black);
                        graph.repaint();
                    }
                }else if(dLength == 2){
                    if(i % 2 == 0 || i % 3 == 0){
                        img.setRGB(x, y0, black);
                        graph.repaint();
                    }
                }else{
                    img.setRGB(x, y0, black);
                    graph.repaint();
                }
            } 
        }else if(y0 == y1){
            //System.out.println("Case 2");
            for(int i = 0; i < dx; i++){
                int y = y0;
                x0 = x0 + 1;
                if(dLength == 1){
                    if(i % 2 == 0){
                        img.setRGB(x0, y, black);
                        graph.repaint();
                    }
                }else if(dLength == 2){
                    if(i % 2 == 0 || i % 3 == 0){
                        img.setRGB(x0, y, black);
                        graph.repaint();
                    }
                }else{
                    img.setRGB(x0, y, black);
                    graph.repaint();
                }
            }
        }else if(dx > dy && y0 < y1){
            //System.out.println("Case 3");
            for(int i = 0; i <= dx; i++){
                int x = x0 + i;
                double dbly = ((double)dy/(double)dx) * i + y0;
                int y = (int)dbly;
                
                if(dLength == 1){
                    if(i % 2 == 0){
                        img.setRGB(x, y, black);
                        graph.repaint();
                    }
                }else if(dLength == 2){
                    if(i % 2 == 0 || x % 3 == 0){
                        img.setRGB(x, y, black);
                        graph.repaint();
                    }
                }else{
                    img.setRGB(x, y, black);
                    graph.repaint();
                }
            }
        }else if(dx > dy && y0 > y1){
            for(int i = 0; i <= dx; i++){
                int x = x0 + i;
                double dbly = ((double)dx/(double)dy) * i + y0;
                int y = (int)dbly;
                
                if(dLength == 1){
                    if(i % 2 == 0){
                        img.setRGB(x, y, black);
                        graph.repaint();
                    }
                }else if(dLength == 2){
                    if(i % 2 == 0 || x % 3 == 0){
                        img.setRGB(x, y, black);
                        graph.repaint();
                    }
                }else{
                    img.setRGB(x, y, black);
                    graph.repaint();
                }
            }
        }else if(dx < dy && y0 < y1){
            //System.out.println("Case 4");
            for(int i = 0; i <= dx; i++){
                int x = x0 + i;
                double dbly = ((double)dy/(double)dx * i) + y0;
                int y = (int)dbly;
                if(dLength == 1){
                    if(i % 2 == 0){
                        img.setRGB(x, y, black);
                        graph.repaint();
                    }
                }else if(dLength == 2){
                    if(i % 2 == 0 || x % 3 == 0){
                        img.setRGB(x, y, black);
                        graph.repaint();
                    }
                }else{
                    img.setRGB(x, y, black);
                    graph.repaint();
                }
            }
        }else if(dx < dy && y0 > y1){
            for(int i = 0; i <= dx; i++){
                int x = x0 + i;
                double dbly = ((double)dx/(double)dy) * i + y0;
                int y = (int)dbly;
                
                if(dLength == 1){
                    if(i % 2 == 0){
                        img.setRGB(x, y, black);
                        graph.repaint();
                    }
                }else if(dLength == 2){
                    if(i % 2 == 0 || x % 3 == 0){
                        img.setRGB(x, y, black);
                        graph.repaint();
                    }
                }else{
                    img.setRGB(x, y, black);
                    graph.repaint();
                }
            }
        }
        
        endTime = System.nanoTime() - startTime;
    }// simpleLineScan()
    
    /**
     * bresenham().
     * Bresenham's line algorithm as adapted from optional
     * Graphics Textbook for CSCI 4800.
     * 
     * @param x0 Integer - lower bound x coordinate of the line
     * @param y0 Integer - lower bound y coordinate of the line
     * @param x1 Integer - upper bound x coordinate of the line
     * @param y1 Integer - upper bound y coordinate of the line
     * @param dLength - Integer line type, i.e. 0 creates a solid line
     */
    public static void bresenham(int x0, int y0, int x1, int y1, int dLength){
        int dx = x1 - x0;
        int dy = y1 - y0;
        long startTime = System.nanoTime();
        // Start position
        if(x0 == x1){
            int x;
            for(int i = 0; i < dy; i++){
                x = x0;
                y0 = y0 + 1;

                if(dLength == 1){
                    if(i % 2 == 0){
                        img.setRGB(x, y0, black);
                        graph.repaint();
                    }
                }else if(dLength == 2){
                    if(i % 2 == 0 || i % 3 == 0){
                        img.setRGB(x, y0, black);
                        graph.repaint();
                    }
                }else{
                    img.setRGB(x, y0, black);
                    graph.repaint();
                }
                
            } 
        }else if(y0 == y1){
            int y;
            for(int i = 0; i < dx; i++){
                y = y0;
                x0 = x0 + 1;

                if(dLength == 1){
                    if(i % 2 == 0){
                        img.setRGB(x0, y, black);
                        graph.repaint();
                    }
                }else if(dLength == 2){
                    if(i % 2 == 0 || i % 3 == 0){
                        img.setRGB(x0, y, black);
                        graph.repaint();
                    }
                }else{
                    img.setRGB(x0, y, black);
                    graph.repaint();
                }
            }
        }else if(dx == dy){
                       int p = (2 * dy) - dx;
            int twoDy = 2 * dy;
            int twoDyMinusDx = 2 * (dy - dx);
            int x, y;
            if(x0 > x1){
                x = x1;
                y = y1;
                x1 = x0;
            }else{
                x = x0;
                y = y0;
            }
            img.setRGB(x, y, black);
            while(x < x1){
                x++;
                if(p < 0){
                    p += twoDy;
                }else{
                    y++;
                    p += twoDyMinusDx;
                }
                
                if(dLength == 1){
                    if(x % 2 == 0){
                        img.setRGB(x, y, black);
                        graph.repaint();
                    }
                }else if(dLength == 2){
                    if(x % 2 == 0 || x % 3 == 0){
                        img.setRGB(x, y, black);
                        graph.repaint();
                    }
                }else{
                    img.setRGB(x, y, black);
                    graph.repaint();
                }
            }
        }else if(dx > dy && y0 < y1){
            int p = (2 * dy) - dx;
            int twoDy = 2 * dy;
            int twoDyMinusDx = 2 * (dy - dx);
            int x, y;
            if(x0 > x1){
                x = x1;
                y = y1;
                x1 = x0;
            }else{
                x = x0;
                y = y0;
            }
            img.setRGB(x, y, black);
            while(x < x1){
                x++;
                if(p < 0){
                    p += twoDy;
                }else{
                    y++;
                    p += twoDyMinusDx;
                }
                
                if(dLength == 1){
                    if(x % 2 == 0){
                        img.setRGB(x, y, black);
                        graph.repaint();
                    }
                }else if(dLength == 2){
                    if(x % 2 == 0 || x % 3 == 0){
                        img.setRGB(x, y, black);
                        graph.repaint();
                    }
                }else{
                    img.setRGB(x, y, black);
                    graph.repaint();
                }
            }
        }else if(dx > dy && y0 > y1){
            int p = (2 * dy) - dx;
            int twoDy = 2 * -dy;
            int twoDyMinusDx = 2 * (dy - dx);
            int x, y;
            if(x0 > x1){
                x = x1;
                y = y1;
                x1 = x0;
            }else{
                x = x0;
                y = y0;
            }
            img.setRGB(x, y, black);
            while(x < x1){
                x++;
                if(p < 0){
                    p += twoDy;
                }else{
                    y--;
                    p += twoDyMinusDx;
                }             
                if(dLength == 1){
                    if(x % 2 == 0){
                        img.setRGB(x, y, black);
                        graph.repaint();
                    }
                }else if(dLength == 2){
                    if(x % 2 == 0 || x % 3 == 0){
                        img.setRGB(x, y, black);
                        graph.repaint();
                    }
                }else{
                    img.setRGB(x, y, black);
                    graph.repaint();
                }
            }
        }else if(dx < dy && y0 < y1){
            int p = (2 * dy) - dx;
            int twoDy = 2 * dy;
            int twoDyMinusDx = 2 * (dy - dx);
            int x, y;
            if(x0 > x1){
                x = x1;
                y = y1;
                x1 = x0;
            }else{
                x = x0;
                y = y0;
            }
            img.setRGB(x, y, black);
            while(x < x1){
                x++;
                if(p < 0){
                    p += twoDy;
                }else{
                    y++;
                    p += twoDyMinusDx;
                }
                
                if(dLength == 1){
                    if(x % 2 == 0){
                        img.setRGB(x, y, black);
                        graph.repaint();
                    }
                }else if(dLength == 2){
                    if(x % 2 == 0 || x % 3 == 0){
                        img.setRGB(x, y, black);
                        graph.repaint();
                    }
                }else{
                    img.setRGB(x, y, black);
                    graph.repaint();
                }
            }
        }else if(dx < dy && y0 > y1){
            int p = (2 * dy) - dx;
            int twoDy = 2 * -dy;
            int twoDyMinusDx = 2 * (dy - dx);
            int x, y;
            if(x0 > x1){
                x = x1;
                y = y1;
                x1 = x0;
            }else{
                x = x0;
                y = y0;
            }
            img.setRGB(x, y, black);
            while(x < x1){
                x++;
                if(p < 0){
                    p += twoDy;
                }else{
                    y--;
                    p += twoDyMinusDx;
                }             
                if(dLength == 1){
                    if(x % 2 == 0){
                        img.setRGB(x, y, black);
                        graph.repaint();
                    }
                }else if(dLength == 2){
                    if(x % 2 == 0 || x % 3 == 0){
                        img.setRGB(x, y, black);
                        graph.repaint();
                    }
                }else{
                    img.setRGB(x, y, black);
                    //img.setRGB(x, y, black);
                    graph.repaint();
                }
            }
        }
        
        endTime = System.nanoTime() - startTime;
    }// bresenham()
    
    /**
     * getTimeElapsed.
     * Returns the time either the Bresenham or Simple Line Scan algorithm
     * takes to draw a certain number of lines. 
     * @return long endTime
     */
    public static long getTimeElapsed(){
        return endTime;
    }// getTimeElapsed()
    
}// class
